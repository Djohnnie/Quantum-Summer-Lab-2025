// <auto-generated>
//     This file was generated by uniffi-bindgen-cs v0.9.0+v0.28.3
//     See https://github.com/NordSecurity/uniffi-bindgen-cs for more information.
// </auto-generated>

#nullable enable




using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Threading;
namespace QsharpBridge;



// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

[StructLayout(LayoutKind.Sequential)]
internal struct RustBuffer {
    public ulong capacity;
    public ulong len;
    public IntPtr data;

    public static RustBuffer Alloc(int size) {
        return _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            var buffer = _UniFFILib.ffi_qsharp_bridge_rustbuffer_alloc(Convert.ToUInt64(size), ref status);
            if (buffer.data == IntPtr.Zero) {
                throw new AllocationException($"RustBuffer.Alloc() returned null data pointer (size={size})");
            }
            return buffer;
        });
    }

    public static void Free(RustBuffer buffer) {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            _UniFFILib.ffi_qsharp_bridge_rustbuffer_free(buffer, ref status);
        });
    }

    public static BigEndianStream MemoryStream(IntPtr data, long length)
    {
        unsafe
        {
            return new BigEndianStream(new UnmanagedMemoryStream((byte*)data.ToPointer(), length));
        }
    }

    public BigEndianStream AsStream()
    {
        unsafe
        {
            return new BigEndianStream(
                new UnmanagedMemoryStream((byte*)data.ToPointer(), Convert.ToInt64(len))
            );
        }
    }

    public BigEndianStream AsWriteableStream()
    {
        unsafe
        {
            return new BigEndianStream(
                new UnmanagedMemoryStream(
                    (byte*)data.ToPointer(),
                    Convert.ToInt64(capacity),
                    Convert.ToInt64(capacity),
                    FileAccess.Write
                )
            );
        }
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to managed memory, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

[StructLayout(LayoutKind.Sequential)]
internal struct ForeignBytes {
    public int length;
    public IntPtr data;
}


// The FfiConverter interface handles converter types to and from the FFI
//
// All implementing objects should be public to support external types.  When a
// type is external we need to import it's FfiConverter.
internal abstract class FfiConverter<CsType, FfiType> {
    // Convert an FFI type to a C# type
    public abstract CsType Lift(FfiType value);

    // Convert C# type to an FFI type
    public abstract FfiType Lower(CsType value);

    // Read a C# type from a `ByteBuffer`
    public abstract CsType Read(BigEndianStream stream);

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    public abstract int AllocationSize(CsType value);

    // Write a C# type to a `ByteBuffer`
    public abstract void Write(CsType value, BigEndianStream stream);

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    public RustBuffer LowerIntoRustBuffer(CsType value) {
        var rbuf = RustBuffer.Alloc(AllocationSize(value));
        try {
            var stream = rbuf.AsWriteableStream();
            Write(value, stream);
            rbuf.len = Convert.ToUInt64(stream.Position);
            return rbuf;
        } catch {
            RustBuffer.Free(rbuf);
            throw;
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    protected CsType LiftFromRustBuffer(RustBuffer rbuf) {
        var stream = rbuf.AsStream();
        try {
           var item = Read(stream);
           if (stream.HasRemaining()) {
               throw new InternalException("junk remaining in buffer after lifting, something is very wrong!!");
           }
           return item;
        } finally {
            RustBuffer.Free(rbuf);
        }
    }
}

// FfiConverter that uses `RustBuffer` as the FfiType
internal abstract class FfiConverterRustBuffer<CsType>: FfiConverter<CsType, RustBuffer> {
    public override CsType Lift(RustBuffer value) {
        return LiftFromRustBuffer(value);
    }
    public override RustBuffer Lower(CsType value) {
        return LowerIntoRustBuffer(value);
    }
}


// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.
// Error runtime.
[StructLayout(LayoutKind.Sequential)]
struct UniffiRustCallStatus {
    public sbyte code;
    public RustBuffer error_buf;

    public bool IsSuccess() {
        return code == 0;
    }

    public bool IsError() {
        return code == 1;
    }

    public bool IsPanic() {
        return code == 2;
    }
}

// Base class for all uniffi exceptions
public class UniffiException: System.Exception {
    public UniffiException(): base() {}
    public UniffiException(string message): base(message) {}
}

public class UndeclaredErrorException: UniffiException {
    public UndeclaredErrorException(string message): base(message) {}
}

public class PanicException: UniffiException {
    public PanicException(string message): base(message) {}
}

public class AllocationException: UniffiException {
    public AllocationException(string message): base(message) {}
}

public class InternalException: UniffiException {
    public InternalException(string message): base(message) {}
}

public class InvalidEnumException: InternalException {
    public InvalidEnumException(string message): base(message) {
    }
}

public class UniffiContractVersionException: UniffiException {
    public UniffiContractVersionException(string message): base(message) {
    }
}

public class UniffiContractChecksumException: UniffiException {
    public UniffiContractChecksumException(string message): base(message) {
    }
}

// Each top-level error class has a companion object that can lift the error from the call status's rust buffer
interface CallStatusErrorHandler<E> where E: System.Exception {
    E Lift(RustBuffer error_buf);
}

// CallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
class NullCallStatusErrorHandler: CallStatusErrorHandler<UniffiException> {
    public static NullCallStatusErrorHandler INSTANCE = new NullCallStatusErrorHandler();

    public UniffiException Lift(RustBuffer error_buf) {
        RustBuffer.Free(error_buf);
        return new UndeclaredErrorException("library has returned an error not declared in UNIFFI interface file");
    }
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself
class _UniffiHelpers {
    public delegate void RustCallAction(ref UniffiRustCallStatus status);
    public delegate U RustCallFunc<out U>(ref UniffiRustCallStatus status);

    // Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
    public static U RustCallWithError<U, E>(CallStatusErrorHandler<E> errorHandler, RustCallFunc<U> callback)
        where E: UniffiException
    {
        var status = new UniffiRustCallStatus();
        var return_value = callback(ref status);
        if (status.IsSuccess()) {
            return return_value;
        } else if (status.IsError()) {
            throw errorHandler.Lift(status.error_buf);
        } else if (status.IsPanic()) {
            // when the rust code sees a panic, it tries to construct a rustbuffer
            // with the message.  but if that code panics, then it just sends back
            // an empty buffer.
            if (status.error_buf.len > 0) {
                throw new PanicException(FfiConverterString.INSTANCE.Lift(status.error_buf));
            } else {
                throw new PanicException("Rust panic");
            }
        } else {
            throw new InternalException($"Unknown rust call status: {status.code}");
        }
    }

    // Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
    public static void RustCallWithError<E>(CallStatusErrorHandler<E> errorHandler, RustCallAction callback)
        where E: UniffiException
    {
        _UniffiHelpers.RustCallWithError(errorHandler, (ref UniffiRustCallStatus status) => {
            callback(ref status);
            return 0;
        });
    }

    // Call a rust function that returns a plain value
    public static U RustCall<U>(RustCallFunc<U> callback) {
        return _UniffiHelpers.RustCallWithError(NullCallStatusErrorHandler.INSTANCE, callback);
    }

    // Call a rust function that returns a plain value
    public static void RustCall(RustCallAction callback) {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            callback(ref status);
            return 0;
        });
    }
}

static class FFIObjectUtil {
    public static void DisposeAll(params Object?[] list) {
        foreach (var obj in list) {
            Dispose(obj);
        }
    }

    // Dispose is implemented by recursive type inspection at runtime. This is because
    // generating correct Dispose calls for recursive complex types, e.g. List<List<int>>
    // is quite cumbersome.
    private static void Dispose(dynamic? obj) {
        if (obj == null) {
            return;
        }

        if (obj is IDisposable disposable) {
            disposable.Dispose();
            return;
        }

        var type = obj.GetType();
        if (type != null) {
            if (type.IsGenericType) {
                if (type.GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))) {
                    foreach (var value in obj) {
                        Dispose(value);
                    }
                } else if (type.GetGenericTypeDefinition().IsAssignableFrom(typeof(Dictionary<,>))) {
                    foreach (var value in obj.Values) {
                        Dispose(value);
                    }
                }
            }
        }
    }
}


// Big endian streams are not yet available in dotnet :'(
// https://github.com/dotnet/runtime/issues/26904

class StreamUnderflowException: System.Exception {
    public StreamUnderflowException() {
    }
}

class BigEndianStream {
    Stream stream;
    public BigEndianStream(Stream stream) {
        this.stream = stream;
    }

    public bool HasRemaining() {
        return (stream.Length - stream.Position) > 0;
    }

    public long Position {
        get => stream.Position;
        set => stream.Position = value;
    }

    public void WriteBytes(byte[] value) {
        stream.Write(value, 0, value.Length);
    }

    public void WriteByte(byte value) {
        stream.WriteByte(value);
    }

    public void WriteUShort(ushort value) {
        stream.WriteByte((byte)(value >> 8));
        stream.WriteByte((byte)value);
    }

    public void WriteUInt(uint value) {
        stream.WriteByte((byte)(value >> 24));
        stream.WriteByte((byte)(value >> 16));
        stream.WriteByte((byte)(value >> 8));
        stream.WriteByte((byte)value);
    }

    public void WriteULong(ulong value) {
        WriteUInt((uint)(value >> 32));
        WriteUInt((uint)value);
    }

    public void WriteSByte(sbyte value) {
        stream.WriteByte((byte)value);
    }

    public void WriteShort(short value) {
        WriteUShort((ushort)value);
    }

    public void WriteInt(int value) {
        WriteUInt((uint)value);
    }

    public void WriteFloat(float value) {
        unsafe {
            WriteInt(*((int*)&value));
        }
    }

    public void WriteLong(long value) {
        WriteULong((ulong)value);
    }

    public void WriteDouble(double value) {
        WriteLong(BitConverter.DoubleToInt64Bits(value));
    }

    public byte[] ReadBytes(int length) {
        CheckRemaining(length);
        byte[] result = new byte[length];
        stream.Read(result, 0, length);
        return result;
    }

    public byte ReadByte() {
        CheckRemaining(1);
        return Convert.ToByte(stream.ReadByte());
    }

    public ushort ReadUShort() {
        CheckRemaining(2);
        return (ushort)(stream.ReadByte() << 8 | stream.ReadByte());
    }

    public uint ReadUInt() {
        CheckRemaining(4);
        return (uint)(stream.ReadByte() << 24
            | stream.ReadByte() << 16
            | stream.ReadByte() << 8
            | stream.ReadByte());
    }

    public ulong ReadULong() {
        return (ulong)ReadUInt() << 32 | (ulong)ReadUInt();
    }

    public sbyte ReadSByte() {
        return (sbyte)ReadByte();
    }

    public short ReadShort() {
        return (short)ReadUShort();
    }

    public int ReadInt() {
        return (int)ReadUInt();
    }

    public float ReadFloat() {
        unsafe {
            int value = ReadInt();
            return *((float*)&value);
        }
    }

    public long ReadLong() {
        return (long)ReadULong();
    }

    public double ReadDouble() {
        return BitConverter.Int64BitsToDouble(ReadLong());
    }

    private void CheckRemaining(int length) {
        if (stream.Length - stream.Position < length) {
            throw new StreamUnderflowException();
        }
    }
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.


// This is an implementation detail that will be called internally by the public API.
static class _UniFFILib {
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiRustFutureContinuationCallback(
        ulong @data,sbyte @pollResult
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureFree(
        ulong @handle
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceFree(
        ulong @handle
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFuture
    {
        public ulong @handle;
        public IntPtr @free;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU8
    {
        public byte @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU8(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructU8 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI8
    {
        public sbyte @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI8(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructI8 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU16
    {
        public ushort @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU16(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructU16 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI16
    {
        public short @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI16(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructI16 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU32
    {
        public uint @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU32(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructU32 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI32
    {
        public int @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI32(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructI32 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU64
    {
        public ulong @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU64(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructU64 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI64
    {
        public long @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI64(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructI64 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructF32
    {
        public float @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteF32(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructF32 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructF64
    {
        public double @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteF64(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructF64 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructPointer
    {
        public IntPtr @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompletePointer(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructPointer @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructRustBuffer
    {
        public RustBuffer @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteRustBuffer(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructRustBuffer @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructVoid
    {
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteVoid(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructVoid @result
    );
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    static _UniFFILib() {
        _UniFFILib.uniffiCheckContractApiVersion();
        _UniFFILib.uniffiCheckApiChecksums();
        
        }

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_qsharp_bridge_fn_clone_executionoptions(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_qsharp_bridge_fn_free_executionoptions(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_qsharp_bridge_fn_constructor_executionoptions_from_noise(RustBuffer @noise,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_qsharp_bridge_fn_constructor_executionoptions_from_shots(uint @shots,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_qsharp_bridge_fn_constructor_executionoptions_new(uint @shots,RustBuffer @noise,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_qsharp_bridge_fn_func_circuit(RustBuffer @source,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_qsharp_bridge_fn_func_estimate(RustBuffer @source,RustBuffer @jobParams,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_qsharp_bridge_fn_func_estimate_expression(RustBuffer @expression,RustBuffer @jobParams,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_qsharp_bridge_fn_func_qasm2(RustBuffer @source,RustBuffer @generationOptions,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_qsharp_bridge_fn_func_qasm2_expression(RustBuffer @expression,RustBuffer @generationOptions,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_qsharp_bridge_fn_func_qir(RustBuffer @expression,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_qsharp_bridge_fn_func_run_qs(RustBuffer @source,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_qsharp_bridge_fn_func_run_qs_with_options(RustBuffer @source,IntPtr @options,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_qsharp_bridge_rustbuffer_alloc(ulong @size,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_qsharp_bridge_rustbuffer_from_bytes(ForeignBytes @bytes,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rustbuffer_free(RustBuffer @buf,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_qsharp_bridge_rustbuffer_reserve(RustBuffer @buf,ulong @additional,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_poll_u8(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_cancel_u8(IntPtr @handle
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_free_u8(IntPtr @handle
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern byte ffi_qsharp_bridge_rust_future_complete_u8(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_poll_i8(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_cancel_i8(IntPtr @handle
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_free_i8(IntPtr @handle
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte ffi_qsharp_bridge_rust_future_complete_i8(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_poll_u16(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_cancel_u16(IntPtr @handle
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_free_u16(IntPtr @handle
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort ffi_qsharp_bridge_rust_future_complete_u16(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_poll_i16(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_cancel_i16(IntPtr @handle
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_free_i16(IntPtr @handle
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern short ffi_qsharp_bridge_rust_future_complete_i16(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_poll_u32(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_cancel_u32(IntPtr @handle
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_free_u32(IntPtr @handle
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern uint ffi_qsharp_bridge_rust_future_complete_u32(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_poll_i32(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_cancel_i32(IntPtr @handle
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_free_i32(IntPtr @handle
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern int ffi_qsharp_bridge_rust_future_complete_i32(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_poll_u64(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_cancel_u64(IntPtr @handle
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_free_u64(IntPtr @handle
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern ulong ffi_qsharp_bridge_rust_future_complete_u64(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_poll_i64(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_cancel_i64(IntPtr @handle
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_free_i64(IntPtr @handle
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern long ffi_qsharp_bridge_rust_future_complete_i64(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_poll_f32(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_cancel_f32(IntPtr @handle
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_free_f32(IntPtr @handle
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern float ffi_qsharp_bridge_rust_future_complete_f32(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_poll_f64(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_cancel_f64(IntPtr @handle
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_free_f64(IntPtr @handle
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern double ffi_qsharp_bridge_rust_future_complete_f64(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_poll_pointer(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_cancel_pointer(IntPtr @handle
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_free_pointer(IntPtr @handle
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr ffi_qsharp_bridge_rust_future_complete_pointer(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_poll_rust_buffer(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_cancel_rust_buffer(IntPtr @handle
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_free_rust_buffer(IntPtr @handle
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_qsharp_bridge_rust_future_complete_rust_buffer(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_poll_void(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_cancel_void(IntPtr @handle
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_free_void(IntPtr @handle
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_qsharp_bridge_rust_future_complete_void(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_qsharp_bridge_checksum_func_circuit(
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_qsharp_bridge_checksum_func_estimate(
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_qsharp_bridge_checksum_func_estimate_expression(
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_qsharp_bridge_checksum_func_qasm2(
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_qsharp_bridge_checksum_func_qasm2_expression(
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_qsharp_bridge_checksum_func_qir(
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_qsharp_bridge_checksum_func_run_qs(
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_qsharp_bridge_checksum_func_run_qs_with_options(
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_qsharp_bridge_checksum_constructor_executionoptions_from_noise(
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_qsharp_bridge_checksum_constructor_executionoptions_from_shots(
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_qsharp_bridge_checksum_constructor_executionoptions_new(
    );

    [DllImport("qsharp_bridge", CallingConvention = CallingConvention.Cdecl)]
    public static extern uint ffi_qsharp_bridge_uniffi_contract_version(
    );

    

    static void uniffiCheckContractApiVersion() {
        var scaffolding_contract_version = _UniFFILib.ffi_qsharp_bridge_uniffi_contract_version();
        if (26 != scaffolding_contract_version) {
            throw new UniffiContractVersionException($"QsharpBridge: uniffi bindings expected version `26`, library returned `{scaffolding_contract_version}`");
        }
    }

    static void uniffiCheckApiChecksums() {
        {
            var checksum = _UniFFILib.uniffi_qsharp_bridge_checksum_func_circuit();
            if (checksum != 48498) {
                throw new UniffiContractChecksumException($"QsharpBridge: uniffi bindings expected function `uniffi_qsharp_bridge_checksum_func_circuit` checksum `48498`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_qsharp_bridge_checksum_func_estimate();
            if (checksum != 18557) {
                throw new UniffiContractChecksumException($"QsharpBridge: uniffi bindings expected function `uniffi_qsharp_bridge_checksum_func_estimate` checksum `18557`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_qsharp_bridge_checksum_func_estimate_expression();
            if (checksum != 47282) {
                throw new UniffiContractChecksumException($"QsharpBridge: uniffi bindings expected function `uniffi_qsharp_bridge_checksum_func_estimate_expression` checksum `47282`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_qsharp_bridge_checksum_func_qasm2();
            if (checksum != 51036) {
                throw new UniffiContractChecksumException($"QsharpBridge: uniffi bindings expected function `uniffi_qsharp_bridge_checksum_func_qasm2` checksum `51036`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_qsharp_bridge_checksum_func_qasm2_expression();
            if (checksum != 46216) {
                throw new UniffiContractChecksumException($"QsharpBridge: uniffi bindings expected function `uniffi_qsharp_bridge_checksum_func_qasm2_expression` checksum `46216`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_qsharp_bridge_checksum_func_qir();
            if (checksum != 29669) {
                throw new UniffiContractChecksumException($"QsharpBridge: uniffi bindings expected function `uniffi_qsharp_bridge_checksum_func_qir` checksum `29669`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_qsharp_bridge_checksum_func_run_qs();
            if (checksum != 32241) {
                throw new UniffiContractChecksumException($"QsharpBridge: uniffi bindings expected function `uniffi_qsharp_bridge_checksum_func_run_qs` checksum `32241`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_qsharp_bridge_checksum_func_run_qs_with_options();
            if (checksum != 15428) {
                throw new UniffiContractChecksumException($"QsharpBridge: uniffi bindings expected function `uniffi_qsharp_bridge_checksum_func_run_qs_with_options` checksum `15428`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_qsharp_bridge_checksum_constructor_executionoptions_from_noise();
            if (checksum != 17683) {
                throw new UniffiContractChecksumException($"QsharpBridge: uniffi bindings expected function `uniffi_qsharp_bridge_checksum_constructor_executionoptions_from_noise` checksum `17683`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_qsharp_bridge_checksum_constructor_executionoptions_from_shots();
            if (checksum != 17042) {
                throw new UniffiContractChecksumException($"QsharpBridge: uniffi bindings expected function `uniffi_qsharp_bridge_checksum_constructor_executionoptions_from_shots` checksum `17042`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_qsharp_bridge_checksum_constructor_executionoptions_new();
            if (checksum != 25227) {
                throw new UniffiContractChecksumException($"QsharpBridge: uniffi bindings expected function `uniffi_qsharp_bridge_checksum_constructor_executionoptions_new` checksum `25227`, library returned `{checksum}`");
            }
        }
    }
}

// Public interface members begin here.

#pragma warning disable 8625




class FfiConverterUInt32: FfiConverter<uint, uint> {
    public static FfiConverterUInt32 INSTANCE = new FfiConverterUInt32();

    public override uint Lift(uint value) {
        return value;
    }

    public override uint Read(BigEndianStream stream) {
        return stream.ReadUInt();
    }

    public override uint Lower(uint value) {
        return value;
    }

    public override int AllocationSize(uint value) {
        return 4;
    }

    public override void Write(uint value, BigEndianStream stream) {
        stream.WriteUInt(value);
    }
}



class FfiConverterUInt64: FfiConverter<ulong, ulong> {
    public static FfiConverterUInt64 INSTANCE = new FfiConverterUInt64();

    public override ulong Lift(ulong value) {
        return value;
    }

    public override ulong Read(BigEndianStream stream) {
        return stream.ReadULong();
    }

    public override ulong Lower(ulong value) {
        return value;
    }

    public override int AllocationSize(ulong value) {
        return 8;
    }

    public override void Write(ulong value, BigEndianStream stream) {
        stream.WriteULong(value);
    }
}



class FfiConverterDouble: FfiConverter<double, double> {
    public static FfiConverterDouble INSTANCE = new FfiConverterDouble();

    public override double Lift(double value) {
        return value;
    }

    public override double Read(BigEndianStream stream) {
        return stream.ReadDouble();
    }

    public override double Lower(double value) {
        return value;
    }

    public override int AllocationSize(double value) {
        return 8;
    }

    public override void Write(double value, BigEndianStream stream) {
        stream.WriteDouble(value);
    }
}



class FfiConverterBoolean: FfiConverter<bool, sbyte> {
    public static FfiConverterBoolean INSTANCE = new FfiConverterBoolean();

    public override bool Lift(sbyte value) {
        return value != 0;
    }

    public override bool Read(BigEndianStream stream) {
        return Lift(stream.ReadSByte());
    }

    public override sbyte Lower(bool value) {
        return value ? (sbyte)1 : (sbyte)0;
    }

    public override int AllocationSize(bool value) {
        return (sbyte)1;
    }

    public override void Write(bool value, BigEndianStream stream) {
        stream.WriteSByte(Lower(value));
    }
}



class FfiConverterString: FfiConverter<string, RustBuffer> {
    public static FfiConverterString INSTANCE = new FfiConverterString();

    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    public override string Lift(RustBuffer value) {
        try {
            var bytes = value.AsStream().ReadBytes(Convert.ToInt32(value.len));
            return System.Text.Encoding.UTF8.GetString(bytes);
        } finally {
            RustBuffer.Free(value);
        }
    }

    public override string Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var bytes = stream.ReadBytes(length);
        return System.Text.Encoding.UTF8.GetString(bytes);
    }

    public override RustBuffer Lower(string value) {
        var bytes = System.Text.Encoding.UTF8.GetBytes(value);
        var rbuf = RustBuffer.Alloc(bytes.Length);
        rbuf.AsWriteableStream().WriteBytes(bytes);
        return rbuf;
    }

    // TODO(CS)
    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per unicode codepoint which will always be
    // enough.
    public override int AllocationSize(string value) {
        const int sizeForLength = 4;
        var sizeForString = System.Text.Encoding.UTF8.GetByteCount(value);
        return sizeForLength + sizeForString;
    }

    public override void Write(string value, BigEndianStream stream) {
        var bytes = System.Text.Encoding.UTF8.GetBytes(value);
        stream.WriteInt(bytes.Length);
        stream.WriteBytes(bytes);
    }
}



public interface IExecutionOptions {
}
public class ExecutionOptions : IExecutionOptions, IDisposable {
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public ExecutionOptions(IntPtr pointer) {
        this.pointer = pointer;
    }

    ~ExecutionOptions() {
        Destroy();
    }
    public ExecutionOptions(uint @shots, PauliDistribution @noise) :
        this(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_qsharp_bridge_fn_constructor_executionoptions_new(FfiConverterUInt32.INSTANCE.Lower(@shots), FfiConverterTypePauliDistribution.INSTANCE.Lower(@noise), ref _status)
)) {}

    protected void FreeRustArcPtr() {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            _UniFFILib.uniffi_qsharp_bridge_fn_free_executionoptions(this.pointer, ref status);
        });
    }

    protected IntPtr CloneRustArcPtr() {
        return _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            return _UniFFILib.uniffi_qsharp_bridge_fn_clone_executionoptions(this.pointer, ref status);
        });
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter() 
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L) throw new System.ObjectDisposedException(String.Format("'{0}' object has already been destroyed", this.GetType().Name));
            if (count == long.MaxValue) throw new System.OverflowException(String.Format("'{0}' call counter would overflow", this.GetType().Name));

        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter() 
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0) {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try {
            action(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {   
        IncrementCallCounter();
        try {
            return func(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    

    
    public static ExecutionOptions FromNoise(PauliDistribution @noise) {
        return new ExecutionOptions(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_qsharp_bridge_fn_constructor_executionoptions_from_noise(FfiConverterTypePauliDistribution.INSTANCE.Lower(@noise), ref _status)
));
    }
    
    public static ExecutionOptions FromShots(uint @shots) {
        return new ExecutionOptions(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_qsharp_bridge_fn_constructor_executionoptions_from_shots(FfiConverterUInt32.INSTANCE.Lower(@shots), ref _status)
));
    }
    
    
}
class FfiConverterTypeExecutionOptions: FfiConverter<ExecutionOptions, IntPtr> {
    public static FfiConverterTypeExecutionOptions INSTANCE = new FfiConverterTypeExecutionOptions();


    public override IntPtr Lower(ExecutionOptions value) {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override ExecutionOptions Lift(IntPtr value) {
        return new ExecutionOptions(value);
    }

    public override ExecutionOptions Read(BigEndianStream stream) {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(ExecutionOptions value) {
        return 8;
    }

    public override void Write(ExecutionOptions value, BigEndianStream stream) {
        stream.WriteLong(Lower(value).ToInt64());
    }
}



public record Circuit (
    List<Operation> @operations, 
    List<Qubit> @qubits
) {
}

class FfiConverterTypeCircuit: FfiConverterRustBuffer<Circuit> {
    public static FfiConverterTypeCircuit INSTANCE = new FfiConverterTypeCircuit();

    public override Circuit Read(BigEndianStream stream) {
        return new Circuit(
            @operations: FfiConverterSequenceTypeOperation.INSTANCE.Read(stream),
            @qubits: FfiConverterSequenceTypeQubit.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Circuit value) {
        return 0
            + FfiConverterSequenceTypeOperation.INSTANCE.AllocationSize(value.@operations)
            + FfiConverterSequenceTypeQubit.INSTANCE.AllocationSize(value.@qubits);
    }

    public override void Write(Circuit value, BigEndianStream stream) {
            FfiConverterSequenceTypeOperation.INSTANCE.Write(value.@operations, stream);
            FfiConverterSequenceTypeQubit.INSTANCE.Write(value.@qubits, stream);
    }
}



public record ExecutionState (
    List<QubitState> @states, 
    ulong @qubitCount, 
    List<string> @messages, 
    string? @result
) {
}

class FfiConverterTypeExecutionState: FfiConverterRustBuffer<ExecutionState> {
    public static FfiConverterTypeExecutionState INSTANCE = new FfiConverterTypeExecutionState();

    public override ExecutionState Read(BigEndianStream stream) {
        return new ExecutionState(
            @states: FfiConverterSequenceTypeQubitState.INSTANCE.Read(stream),
            @qubitCount: FfiConverterUInt64.INSTANCE.Read(stream),
            @messages: FfiConverterSequenceString.INSTANCE.Read(stream),
            @result: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ExecutionState value) {
        return 0
            + FfiConverterSequenceTypeQubitState.INSTANCE.AllocationSize(value.@states)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@qubitCount)
            + FfiConverterSequenceString.INSTANCE.AllocationSize(value.@messages)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@result);
    }

    public override void Write(ExecutionState value, BigEndianStream stream) {
            FfiConverterSequenceTypeQubitState.INSTANCE.Write(value.@states, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@qubitCount, stream);
            FfiConverterSequenceString.INSTANCE.Write(value.@messages, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@result, stream);
    }
}



public record Operation (
    string @gate, 
    string? @displayArgs, 
    bool @isControlled, 
    bool @isAdjoint, 
    bool @isMeasurement, 
    List<Register> @controls, 
    List<Register> @targets, 
    List<Operation> @children
) {
}

class FfiConverterTypeOperation: FfiConverterRustBuffer<Operation> {
    public static FfiConverterTypeOperation INSTANCE = new FfiConverterTypeOperation();

    public override Operation Read(BigEndianStream stream) {
        return new Operation(
            @gate: FfiConverterString.INSTANCE.Read(stream),
            @displayArgs: FfiConverterOptionalString.INSTANCE.Read(stream),
            @isControlled: FfiConverterBoolean.INSTANCE.Read(stream),
            @isAdjoint: FfiConverterBoolean.INSTANCE.Read(stream),
            @isMeasurement: FfiConverterBoolean.INSTANCE.Read(stream),
            @controls: FfiConverterSequenceTypeRegister.INSTANCE.Read(stream),
            @targets: FfiConverterSequenceTypeRegister.INSTANCE.Read(stream),
            @children: FfiConverterSequenceTypeOperation.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Operation value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@gate)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@displayArgs)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isControlled)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isAdjoint)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isMeasurement)
            + FfiConverterSequenceTypeRegister.INSTANCE.AllocationSize(value.@controls)
            + FfiConverterSequenceTypeRegister.INSTANCE.AllocationSize(value.@targets)
            + FfiConverterSequenceTypeOperation.INSTANCE.AllocationSize(value.@children);
    }

    public override void Write(Operation value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@gate, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@displayArgs, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@isControlled, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@isAdjoint, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@isMeasurement, stream);
            FfiConverterSequenceTypeRegister.INSTANCE.Write(value.@controls, stream);
            FfiConverterSequenceTypeRegister.INSTANCE.Write(value.@targets, stream);
            FfiConverterSequenceTypeOperation.INSTANCE.Write(value.@children, stream);
    }
}



public record PauliDistribution (
    double @x, 
    double @y, 
    double @z
) {
}

class FfiConverterTypePauliDistribution: FfiConverterRustBuffer<PauliDistribution> {
    public static FfiConverterTypePauliDistribution INSTANCE = new FfiConverterTypePauliDistribution();

    public override PauliDistribution Read(BigEndianStream stream) {
        return new PauliDistribution(
            @x: FfiConverterDouble.INSTANCE.Read(stream),
            @y: FfiConverterDouble.INSTANCE.Read(stream),
            @z: FfiConverterDouble.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(PauliDistribution value) {
        return 0
            + FfiConverterDouble.INSTANCE.AllocationSize(value.@x)
            + FfiConverterDouble.INSTANCE.AllocationSize(value.@y)
            + FfiConverterDouble.INSTANCE.AllocationSize(value.@z);
    }

    public override void Write(PauliDistribution value, BigEndianStream stream) {
            FfiConverterDouble.INSTANCE.Write(value.@x, stream);
            FfiConverterDouble.INSTANCE.Write(value.@y, stream);
            FfiConverterDouble.INSTANCE.Write(value.@z, stream);
    }
}



public record QasmGenerationOptions (
    bool @includeQelib, 
    QasmResetBehavior @resetBehavior
) {
}

class FfiConverterTypeQasmGenerationOptions: FfiConverterRustBuffer<QasmGenerationOptions> {
    public static FfiConverterTypeQasmGenerationOptions INSTANCE = new FfiConverterTypeQasmGenerationOptions();

    public override QasmGenerationOptions Read(BigEndianStream stream) {
        return new QasmGenerationOptions(
            @includeQelib: FfiConverterBoolean.INSTANCE.Read(stream),
            @resetBehavior: FfiConverterTypeQasmResetBehavior.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(QasmGenerationOptions value) {
        return 0
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@includeQelib)
            + FfiConverterTypeQasmResetBehavior.INSTANCE.AllocationSize(value.@resetBehavior);
    }

    public override void Write(QasmGenerationOptions value, BigEndianStream stream) {
            FfiConverterBoolean.INSTANCE.Write(value.@includeQelib, stream);
            FfiConverterTypeQasmResetBehavior.INSTANCE.Write(value.@resetBehavior, stream);
    }
}



public record Qubit (
    ulong @id, 
    ulong @numChildren
) {
}

class FfiConverterTypeQubit: FfiConverterRustBuffer<Qubit> {
    public static FfiConverterTypeQubit INSTANCE = new FfiConverterTypeQubit();

    public override Qubit Read(BigEndianStream stream) {
        return new Qubit(
            @id: FfiConverterUInt64.INSTANCE.Read(stream),
            @numChildren: FfiConverterUInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Qubit value) {
        return 0
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@id)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@numChildren);
    }

    public override void Write(Qubit value, BigEndianStream stream) {
            FfiConverterUInt64.INSTANCE.Write(value.@id, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@numChildren, stream);
    }
}



public record QubitState (
    string @id, 
    double @amplitudeReal, 
    double @amplitudeImaginary
) {
}

class FfiConverterTypeQubitState: FfiConverterRustBuffer<QubitState> {
    public static FfiConverterTypeQubitState INSTANCE = new FfiConverterTypeQubitState();

    public override QubitState Read(BigEndianStream stream) {
        return new QubitState(
            @id: FfiConverterString.INSTANCE.Read(stream),
            @amplitudeReal: FfiConverterDouble.INSTANCE.Read(stream),
            @amplitudeImaginary: FfiConverterDouble.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(QubitState value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@id)
            + FfiConverterDouble.INSTANCE.AllocationSize(value.@amplitudeReal)
            + FfiConverterDouble.INSTANCE.AllocationSize(value.@amplitudeImaginary);
    }

    public override void Write(QubitState value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@id, stream);
            FfiConverterDouble.INSTANCE.Write(value.@amplitudeReal, stream);
            FfiConverterDouble.INSTANCE.Write(value.@amplitudeImaginary, stream);
    }
}



public record Register (
    ulong @qId, 
    ulong @registerType, 
    ulong? @cId
) {
}

class FfiConverterTypeRegister: FfiConverterRustBuffer<Register> {
    public static FfiConverterTypeRegister INSTANCE = new FfiConverterTypeRegister();

    public override Register Read(BigEndianStream stream) {
        return new Register(
            @qId: FfiConverterUInt64.INSTANCE.Read(stream),
            @registerType: FfiConverterUInt64.INSTANCE.Read(stream),
            @cId: FfiConverterOptionalUInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Register value) {
        return 0
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@qId)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@registerType)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@cId);
    }

    public override void Write(Register value, BigEndianStream stream) {
            FfiConverterUInt64.INSTANCE.Write(value.@qId, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@registerType, stream);
            FfiConverterOptionalUInt64.INSTANCE.Write(value.@cId, stream);
    }
}





public enum QasmResetBehavior: int {
    
    Supported,
    Ignored,
    Error
}

class FfiConverterTypeQasmResetBehavior: FfiConverterRustBuffer<QasmResetBehavior> {
    public static FfiConverterTypeQasmResetBehavior INSTANCE = new FfiConverterTypeQasmResetBehavior();

    public override QasmResetBehavior Read(BigEndianStream stream) {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(QasmResetBehavior), value)) {
            return (QasmResetBehavior)value;
        } else {
            throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeQasmResetBehavior.Read()", value));
        }
    }

    public override int AllocationSize(QasmResetBehavior value) {
        return 4;
    }

    public override void Write(QasmResetBehavior value, BigEndianStream stream) {
        stream.WriteInt((int)value + 1);
    }
}







public class QsException: UniffiException {
    QsException() : base() {}
    QsException(String @Message) : base(@Message) {}

    // Each variant is a nested class
    
    
    public class ErrorMessage : QsException {
        // Members
        public string @errorText;

        // Constructor
        public ErrorMessage(
                string @errorText) : base(
                "@errorText" + "=" + @errorText) {

            this.@errorText = @errorText;
        }
    }
    

    
}

class FfiConverterTypeQsError : FfiConverterRustBuffer<QsException>, CallStatusErrorHandler<QsException> {
    public static FfiConverterTypeQsError INSTANCE = new FfiConverterTypeQsError();

    public override QsException Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new QsException.ErrorMessage(
                    FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeQsError.Read()", value));
        }
    }

    public override int AllocationSize(QsException value) {
        switch (value) {

            case QsException.ErrorMessage variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@errorText);
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeQsError.AllocationSize()", value));
        }
    }

    public override void Write(QsException value, BigEndianStream stream) {
        switch (value) {
            case QsException.ErrorMessage variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@errorText, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeQsError.Write()", value));
        }
    }
}




class FfiConverterOptionalUInt64: FfiConverterRustBuffer<ulong?> {
    public static FfiConverterOptionalUInt64 INSTANCE = new FfiConverterOptionalUInt64();

    public override ulong? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterUInt64.INSTANCE.Read(stream);
    }

    public override int AllocationSize(ulong? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterUInt64.INSTANCE.AllocationSize((ulong)value);
        }
    }

    public override void Write(ulong? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterUInt64.INSTANCE.Write((ulong)value, stream);
        }
    }
}




class FfiConverterOptionalString: FfiConverterRustBuffer<string?> {
    public static FfiConverterOptionalString INSTANCE = new FfiConverterOptionalString();

    public override string? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterString.INSTANCE.Read(stream);
    }

    public override int AllocationSize(string? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterString.INSTANCE.AllocationSize((string)value);
        }
    }

    public override void Write(string? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterString.INSTANCE.Write((string)value, stream);
        }
    }
}




class FfiConverterSequenceString: FfiConverterRustBuffer<List<string>> {
    public static FfiConverterSequenceString INSTANCE = new FfiConverterSequenceString();

    public override List<string> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<string>(length);
        for (int i = 0; i < length; i++) {
            result.Add(FfiConverterString.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<string> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterString.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<string> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterString.INSTANCE.Write(item, stream));
    }
}




class FfiConverterSequenceTypeExecutionState: FfiConverterRustBuffer<List<ExecutionState>> {
    public static FfiConverterSequenceTypeExecutionState INSTANCE = new FfiConverterSequenceTypeExecutionState();

    public override List<ExecutionState> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<ExecutionState>(length);
        for (int i = 0; i < length; i++) {
            result.Add(FfiConverterTypeExecutionState.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<ExecutionState> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeExecutionState.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<ExecutionState> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeExecutionState.INSTANCE.Write(item, stream));
    }
}




class FfiConverterSequenceTypeOperation: FfiConverterRustBuffer<List<Operation>> {
    public static FfiConverterSequenceTypeOperation INSTANCE = new FfiConverterSequenceTypeOperation();

    public override List<Operation> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<Operation>(length);
        for (int i = 0; i < length; i++) {
            result.Add(FfiConverterTypeOperation.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<Operation> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeOperation.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<Operation> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeOperation.INSTANCE.Write(item, stream));
    }
}




class FfiConverterSequenceTypeQubit: FfiConverterRustBuffer<List<Qubit>> {
    public static FfiConverterSequenceTypeQubit INSTANCE = new FfiConverterSequenceTypeQubit();

    public override List<Qubit> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<Qubit>(length);
        for (int i = 0; i < length; i++) {
            result.Add(FfiConverterTypeQubit.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<Qubit> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeQubit.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<Qubit> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeQubit.INSTANCE.Write(item, stream));
    }
}




class FfiConverterSequenceTypeQubitState: FfiConverterRustBuffer<List<QubitState>> {
    public static FfiConverterSequenceTypeQubitState INSTANCE = new FfiConverterSequenceTypeQubitState();

    public override List<QubitState> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<QubitState>(length);
        for (int i = 0; i < length; i++) {
            result.Add(FfiConverterTypeQubitState.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<QubitState> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeQubitState.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<QubitState> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeQubitState.INSTANCE.Write(item, stream));
    }
}




class FfiConverterSequenceTypeRegister: FfiConverterRustBuffer<List<Register>> {
    public static FfiConverterSequenceTypeRegister INSTANCE = new FfiConverterSequenceTypeRegister();

    public override List<Register> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<Register>(length);
        for (int i = 0; i < length; i++) {
            result.Add(FfiConverterTypeRegister.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<Register> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeRegister.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<Register> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeRegister.INSTANCE.Write(item, stream));
    }
}
#pragma warning restore 8625
public static class GlobalQsharpBridge {
    /// <exception cref="QsException"></exception>
    public static Circuit Circuit(string @source) {
        return FfiConverterTypeCircuit.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeQsError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_qsharp_bridge_fn_func_circuit(FfiConverterString.INSTANCE.Lower(@source), ref _status)
));
    }


    /// <exception cref="QsException"></exception>
    public static string Estimate(string @source, string? @jobParams) {
        return FfiConverterString.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeQsError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_qsharp_bridge_fn_func_estimate(FfiConverterString.INSTANCE.Lower(@source), FfiConverterOptionalString.INSTANCE.Lower(@jobParams), ref _status)
));
    }


    /// <exception cref="QsException"></exception>
    public static string EstimateExpression(string @expression, string? @jobParams) {
        return FfiConverterString.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeQsError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_qsharp_bridge_fn_func_estimate_expression(FfiConverterString.INSTANCE.Lower(@expression), FfiConverterOptionalString.INSTANCE.Lower(@jobParams), ref _status)
));
    }


    /// <exception cref="QsException"></exception>
    public static string Qasm2(string @source, QasmGenerationOptions @generationOptions) {
        return FfiConverterString.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeQsError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_qsharp_bridge_fn_func_qasm2(FfiConverterString.INSTANCE.Lower(@source), FfiConverterTypeQasmGenerationOptions.INSTANCE.Lower(@generationOptions), ref _status)
));
    }


    /// <exception cref="QsException"></exception>
    public static string Qasm2Expression(string @expression, QasmGenerationOptions @generationOptions) {
        return FfiConverterString.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeQsError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_qsharp_bridge_fn_func_qasm2_expression(FfiConverterString.INSTANCE.Lower(@expression), FfiConverterTypeQasmGenerationOptions.INSTANCE.Lower(@generationOptions), ref _status)
));
    }


    /// <exception cref="QsException"></exception>
    public static string Qir(string @expression) {
        return FfiConverterString.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeQsError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_qsharp_bridge_fn_func_qir(FfiConverterString.INSTANCE.Lower(@expression), ref _status)
));
    }


    /// <exception cref="QsException"></exception>
    public static ExecutionState RunQs(string @source) {
        return FfiConverterTypeExecutionState.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeQsError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_qsharp_bridge_fn_func_run_qs(FfiConverterString.INSTANCE.Lower(@source), ref _status)
));
    }


    /// <exception cref="QsException"></exception>
    public static List<ExecutionState> RunQsWithOptions(string @source, ExecutionOptions @options) {
        return FfiConverterSequenceTypeExecutionState.INSTANCE.Lift(
    _UniffiHelpers.RustCallWithError(FfiConverterTypeQsError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_qsharp_bridge_fn_func_run_qs_with_options(FfiConverterString.INSTANCE.Lower(@source), FfiConverterTypeExecutionOptions.INSTANCE.Lower(@options), ref _status)
));
    }


}

